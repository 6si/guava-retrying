{"name":"guava-retrying","tagline":"This is a small extension to Google's Guava library to allow for the creation of configurable retrying strategies for an arbitrary function call, such as something that talks to a remote service with flaky uptime.","body":"[![Build Status](https://travis-ci.org/rholder/guava-retrying.png)](https://travis-ci.org/rholder/guava-retrying)\r\n\r\n##What is this?\r\nThe guava-retrying module provides a general purpose method for retrying arbitrary Java code with specific stop, retry,\r\nand exception handling capabilities that are enhanced by Guava's predicate matching.\r\n\r\nThis is a fork of the excellent RetryerBuilder code posted [here](http://code.google.com/p/guava-libraries/issues/detail?id=490)\r\nby Jean-Baptiste Nizet (JB).  I've added a Gradle build for pushing it up to my little corner of Maven Central so that\r\nothers can easily pull it into their existing projects with minimal effort.  It also includes\r\nexponential and Fibonacci backoff [WaitStrategies](http://rholder.github.io/guava-retrying/javadoc/1.0.5/com/github/rholder/retry/WaitStrategies.html)\r\nthat might be useful for situations where more well-behaved service polling is preferred.\r\n\r\n##Maven\r\n```xml\r\n    <dependency>\r\n      <groupId>com.github.rholder</groupId>\r\n      <artifactId>guava-retrying</artifactId>\r\n      <version>1.0.5</version>\r\n    </dependency>\r\n```\r\n\r\n##Gradle\r\n```groovy\r\n    compile \"com.github.rholder:guava-retrying:1.0.5\"\r\n```\r\n\r\n##Quickstart\r\nA minimal sample of some of the functionality would look like:\r\n\r\n```java\r\nCallable<Boolean> callable = new Callable<Boolean>() {\r\n    public Boolean call() throws Exception {\r\n        return true; // do something useful here\r\n    }\r\n};\r\n\r\nRetryer<Boolean> retryer = RetryerBuilder.<Boolean>newBuilder()\r\n        .retryIfResult(Predicates.<Boolean>isNull())\r\n        .retryIfExceptionOfType(IOException.class)\r\n        .retryIfRuntimeException()\r\n        .withStopStrategy(StopStrategies.stopAfterAttempt(3))\r\n        .build();\r\ntry {\r\n    retryer.call(callable);\r\n} catch (RetryException e) {\r\n    e.printStackTrace();\r\n} catch (ExecutionException e) {\r\n    e.printStackTrace();\r\n}\r\n```\r\n\r\nThis will retry whenever the result of the `Callable` is null, if an `IOException` is thrown, or if any other\r\n`RuntimeException` is thrown from the `call()` method. It will stop after attempting to retry 3 times and throw a\r\n`RetryException` that contains information about the last failed attempt. If any other `Exception` pops out of the\r\n`call()` method it's wrapped and rethrown in an `ExecutionException`.\r\n\r\n##Exponential Backoff\r\n\r\nCreate a `Retryer` that retries forever, waiting after every failed retry in increasing exponential backoff intervals\r\nuntil at most 5 minutes. After 5 minutes, retry from then on in 5 minute intervals.\r\n\r\n```java\r\nRetryer<Boolean> retryer = RetryerBuilder.<Boolean>newBuilder()\r\n        .retryIfExceptionOfType(IOException.class)\r\n        .retryIfRuntimeException()\r\n        .withWaitStrategy(WaitStrategies.exponentialWait(10, 5, MINUTES))\r\n        .withStopStrategy(StopStrategies.neverStop())\r\n        .build();\r\n```\r\nYou can read more about [exponential backoff](http://en.wikipedia.org/wiki/Exponential_backoff) and the historic role\r\nit played in the development of TCP/IP in [Congestion Avoidance and Control](http://ee.lbl.gov/papers/congavoid.pdf).\r\n\r\n##Fibonacci Backoff\r\n\r\nCreate a `Retryer` that retries forever, waiting after every failed retry in increasing Fibonacci backoff intervals\r\nuntil at most 2 minutes. After 2 minutes, retry from then on in 2 minute intervals.\r\n\r\n```java\r\nRetryer<Boolean> retryer = RetryerBuilder.<Boolean>newBuilder()\r\n        .retryIfExceptionOfType(IOException.class)\r\n        .retryIfRuntimeException()\r\n        .withWaitStrategy(WaitStrategies.fibonacciWait(100, 2, MINUTES))\r\n        .withStopStrategy(StopStrategies.neverStop())\r\n        .build();\r\n```\r\n\r\nSimilar to the `ExponentialWaitStrategy`, the `FibonacciWaitStrategy` follows a pattern of waiting an increasing amount\r\nof time after each failed attempt.\r\n\r\nInstead of an exponential function it's (obviously) using a\r\n[Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_numbers) to calculate the wait time.\r\n\r\nDepending on the problem at hand, the `FibonacciWaitStrategy` might perform better and lead to better throughput than\r\nthe `ExponentialWaitStrategy` - at least according to\r\n[A Performance Comparison of Different Backoff Algorithms under Different Rebroadcast Probabilities for MANETs](http://www.comp.leeds.ac.uk/ukpew09/papers/12.pdf).\r\n\r\nThe implementation of `FibonacciWaitStrategy` is using an iterative version of the Fibonacci because a (naive) recursive\r\nversion will lead to a [StackOverflowError](http://docs.oracle.com/javase/7/docs/api/java/lang/StackOverflowError.html)\r\nat a certain point (although very unlikely with useful parameters for retrying).\r\n\r\nInspiration for this implementation came from [Efficient retry/backoff mechanisms](https://paperairoplane.net/?p=640).\r\n\r\n##Documentation\r\nJavadoc can be found [here](http://rholder.github.io/guava-retrying/javadoc/1.0.5).\r\n\r\n##Building from source\r\nThe guava-retrying module uses a [Gradle](http://gradle.org)-based build system. In the instructions\r\nbelow, [`./gradlew`](http://vimeo.com/34436402) is invoked from the root of the source tree and serves as\r\na cross-platform, self-contained bootstrap mechanism for the build. The only\r\nprerequisites are [Git](https://help.github.com/articles/set-up-git) and JDK 1.6+.\r\n\r\n### check out sources\r\n`git clone git://github.com/rholder/guava-retrying.git`\r\n\r\n### compile and test, build all jars\r\n`./gradlew build`\r\n\r\n### install all jars into your local Maven cache\r\n`./gradlew install`\r\n\r\n##License\r\nThe guava-retrying module is released under version 2.0 of the\r\n[Apache License](http://www.apache.org/licenses/LICENSE-2.0).\r\n\r\n##Contributors\r\n* Jean-Baptiste Nizet (JB)\r\n* Jason Dunkelberger (dirkraft)\r\n* Diwaker Gupta (diwakergupta)\r\n* Jochen Schalanda (joschi)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}